{"version":3,"sources":["../node_modules/@ionic/core/dist/esm-es5/ion-virtual-scroll.entry.js"],"names":["__webpack_require__","r","__webpack_exports__","d","VirtualScroll","tslib__WEBPACK_IMPORTED_MODULE_0__","_chunk_84f6bf13_js__WEBPACK_IMPORTED_MODULE_1__","createNode","el","type","template","getTemplate","ownerDocument","importNode","content","children","querySelector","calcCells","items","itemHeight","headerHeight","footerHeight","headerFn","footerFn","approxHeaderHeight","approxFooterHeight","approxItemHeight","j","offset","len","cells","end","i","value","item","push","index","height","reads","visible","hostRef","_this","this","Object","range","length","viewportHeight","virtualDom","isEnabled","viewportOffset","currentScrollTop","indexDirty","lastItemLen","totalHeight","onScroll","updateVirtualScroll","prototype","itemsChanged","componentDidLoad","contentEl","_a","_b","label","closest","componentOnReady","console","error","sent","getScrollElement","scrollEl","updateState","componentDidUpdate","componentDidUnload","undefined","onResize","positionForItem","Promise","resolve","heightIndex","cell","find","c","positionForIndex","getHeightIndex","checkRange","cellIndex","max","findIndex","findCellIndex","dst","src","inplaceUpdate","Math","scheduleUpdate","checkEnd","timerUpdate","clearTimeout","readVS","bind","writeVS","topOffset","node","offsetTop","parentElement","offsetHeight","scrollTop","dirtyIndex","viewport","vierportHeight","margin","top","bottom","getViewport","buffer","topPos","bottomPos","min","getRange","currentRange","getShouldUpdate","dom","_i","dom_1","change","toMutate","_loop_1","n","pool","filter","_loop_2","toMutate_1","forEach","updateVDom","nodeRender","updateCellHeight","child","Array","from","tagName","childrenNu","newChild","classList","add","appendChild","style","transform","remove","doRender","domRender","renderItem","forceUpdate","update","window","getComputedStyle","parseFloat","getPropertyValue","setCellHeight","then","setTimeout","shouldEnable","enableScrollEvents","Infinity","calcHeightIndex","buf","Uint32Array","newBuf","set","subarray","resizeBuffer","acum","shouldListen","rmEvent","addEventListener","removeEventListener","renderVirtualNode","renderHeader","renderFooter","hostData","__stencil_render","VirtualProxy","map","defineProperty","get","enumerable","configurable","render","utils","vattrs","classes","class","assign"],"mappings":"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","file":"static/js/91.b2d4dab0.chunk.js","sourcesContent":["import * as tslib_1 from \"tslib\";\nimport { r as registerInstance, f as readTask, w as writeTask, h, e as getElement, H as Host } from './chunk-84f6bf13.js';\nimport './chunk-1074393c.js';\nvar CELL_TYPE_ITEM = 'item';\nvar CELL_TYPE_HEADER = 'header';\nvar CELL_TYPE_FOOTER = 'footer';\nvar NODE_CHANGE_NONE = 0;\nvar NODE_CHANGE_POSITION = 1;\nvar NODE_CHANGE_CELL = 2;\nvar MIN_READS = 2;\n\nvar updateVDom = function updateVDom(dom, heightIndex, cells, range) {\n  // reset dom\n  for (var _i = 0, dom_1 = dom; _i < dom_1.length; _i++) {\n    var node = dom_1[_i];\n    node.change = NODE_CHANGE_NONE;\n    node.d = true;\n  } // try to match into exisiting dom\n\n\n  var toMutate = [];\n  var end = range.offset + range.length;\n\n  var _loop_1 = function _loop_1(i) {\n    var cell = cells[i];\n    var node = dom.find(function (n) {\n      return n.d && n.cell === cell;\n    });\n\n    if (node) {\n      var top = heightIndex[i];\n\n      if (top !== node.top) {\n        node.top = top;\n        node.change = NODE_CHANGE_POSITION;\n      }\n\n      node.d = false;\n    } else {\n      toMutate.push(cell);\n    }\n  };\n\n  for (var i = range.offset; i < end; i++) {\n    _loop_1(i);\n  } // needs to append\n\n\n  var pool = dom.filter(function (n) {\n    return n.d;\n  });\n\n  var _loop_2 = function _loop_2(cell) {\n    var node = pool.find(function (n) {\n      return n.d && n.cell.type === cell.type;\n    });\n    var index = cell.i;\n\n    if (node) {\n      node.d = false;\n      node.change = NODE_CHANGE_CELL;\n      node.cell = cell;\n      node.top = heightIndex[index];\n    } else {\n      dom.push({\n        d: false,\n        cell: cell,\n        visible: true,\n        change: NODE_CHANGE_CELL,\n        top: heightIndex[index]\n      });\n    }\n  };\n\n  for (var _a = 0, toMutate_1 = toMutate; _a < toMutate_1.length; _a++) {\n    var cell = toMutate_1[_a];\n\n    _loop_2(cell);\n  }\n\n  dom.filter(function (n) {\n    return n.d && n.top !== -9999;\n  }).forEach(function (n) {\n    n.change = NODE_CHANGE_POSITION;\n    n.top = -9999;\n  });\n};\n\nvar doRender = function doRender(el, nodeRender, dom, updateCellHeight) {\n  var children = Array.from(el.children).filter(function (n) {\n    return n.tagName !== 'TEMPLATE';\n  });\n  var childrenNu = children.length;\n  var child;\n\n  for (var i = 0; i < dom.length; i++) {\n    var node = dom[i];\n    var cell = node.cell; // the cell change, the content must be updated\n\n    if (node.change === NODE_CHANGE_CELL) {\n      if (i < childrenNu) {\n        child = children[i];\n        nodeRender(child, cell, i);\n      } else {\n        var newChild = createNode(el, cell.type);\n        child = nodeRender(newChild, cell, i) || newChild;\n        child.classList.add('virtual-item');\n        el.appendChild(child);\n      }\n\n      child['$ionCell'] = cell;\n    } else {\n      child = children[i];\n    } // only update position when it changes\n\n\n    if (node.change !== NODE_CHANGE_NONE) {\n      child.style.transform = \"translate3d(0,\" + node.top + \"px,0)\";\n    } // update visibility\n\n\n    var visible = cell.visible;\n\n    if (node.visible !== visible) {\n      if (visible) {\n        child.classList.remove('virtual-loading');\n      } else {\n        child.classList.add('virtual-loading');\n      }\n\n      node.visible = visible;\n    } // dynamic height\n\n\n    if (cell.reads > 0) {\n      updateCellHeight(cell, child);\n      cell.reads--;\n    }\n  }\n};\n\nvar createNode = function createNode(el, type) {\n  var template = getTemplate(el, type);\n\n  if (template && el.ownerDocument) {\n    return el.ownerDocument.importNode(template.content, true).children[0];\n  }\n\n  return null;\n};\n\nvar getTemplate = function getTemplate(el, type) {\n  switch (type) {\n    case CELL_TYPE_ITEM:\n      return el.querySelector('template:not([name])');\n\n    case CELL_TYPE_HEADER:\n      return el.querySelector('template[name=header]');\n\n    case CELL_TYPE_FOOTER:\n      return el.querySelector('template[name=footer]');\n  }\n};\n\nvar getViewport = function getViewport(scrollTop, vierportHeight, margin) {\n  return {\n    top: Math.max(scrollTop - margin, 0),\n    bottom: scrollTop + vierportHeight + margin\n  };\n};\n\nvar getRange = function getRange(heightIndex, viewport, buffer) {\n  var topPos = viewport.top;\n  var bottomPos = viewport.bottom; // find top index\n\n  var i = 0;\n\n  for (; i < heightIndex.length; i++) {\n    if (heightIndex[i] > topPos) {\n      break;\n    }\n  }\n\n  var offset = Math.max(i - buffer - 1, 0); // find bottom index\n\n  for (; i < heightIndex.length; i++) {\n    if (heightIndex[i] >= bottomPos) {\n      break;\n    }\n  }\n\n  var end = Math.min(i + buffer, heightIndex.length);\n  var length = end - offset;\n  return {\n    offset: offset,\n    length: length\n  };\n};\n\nvar getShouldUpdate = function getShouldUpdate(dirtyIndex, currentRange, range) {\n  var end = range.offset + range.length;\n  return dirtyIndex <= end || currentRange.offset !== range.offset || currentRange.length !== range.length;\n};\n\nvar findCellIndex = function findCellIndex(cells, index) {\n  var max = cells.length > 0 ? cells[cells.length - 1].index : 0;\n\n  if (index === 0) {\n    return 0;\n  } else if (index === max + 1) {\n    return cells.length;\n  } else {\n    return cells.findIndex(function (c) {\n      return c.index === index;\n    });\n  }\n};\n\nvar inplaceUpdate = function inplaceUpdate(dst, src, offset) {\n  if (offset === 0 && src.length >= dst.length) {\n    return src;\n  }\n\n  for (var i = 0; i < src.length; i++) {\n    dst[i + offset] = src[i];\n  }\n\n  return dst;\n};\n\nvar calcCells = function calcCells(items, itemHeight, headerHeight, footerHeight, headerFn, footerFn, approxHeaderHeight, approxFooterHeight, approxItemHeight, j, offset, len) {\n  var cells = [];\n  var end = len + offset;\n\n  for (var i = offset; i < end; i++) {\n    var item = items[i];\n\n    if (headerFn) {\n      var value = headerFn(item, i, items);\n\n      if (value != null) {\n        cells.push({\n          i: j++,\n          type: CELL_TYPE_HEADER,\n          value: value,\n          index: i,\n          height: headerHeight ? headerHeight(value, i) : approxHeaderHeight,\n          reads: headerHeight ? 0 : MIN_READS,\n          visible: !!headerHeight\n        });\n      }\n    }\n\n    cells.push({\n      i: j++,\n      type: CELL_TYPE_ITEM,\n      value: item,\n      index: i,\n      height: itemHeight ? itemHeight(item, i) : approxItemHeight,\n      reads: itemHeight ? 0 : MIN_READS,\n      visible: !!itemHeight\n    });\n\n    if (footerFn) {\n      var value = footerFn(item, i, items);\n\n      if (value != null) {\n        cells.push({\n          i: j++,\n          type: CELL_TYPE_FOOTER,\n          value: value,\n          index: i,\n          height: footerHeight ? footerHeight(value, i) : approxFooterHeight,\n          reads: footerHeight ? 0 : MIN_READS,\n          visible: !!footerHeight\n        });\n      }\n    }\n  }\n\n  return cells;\n};\n\nvar calcHeightIndex = function calcHeightIndex(buf, cells, index) {\n  var acum = buf[index];\n\n  for (var i = index; i < buf.length; i++) {\n    buf[i] = acum;\n    acum += cells[i].height;\n  }\n\n  return acum;\n};\n\nvar resizeBuffer = function resizeBuffer(buf, len) {\n  if (!buf) {\n    return new Uint32Array(len);\n  }\n\n  if (buf.length === len) {\n    return buf;\n  } else if (len > buf.length) {\n    var newBuf = new Uint32Array(len);\n    newBuf.set(buf);\n    return newBuf;\n  } else {\n    return buf.subarray(0, len);\n  }\n};\n\nvar positionForIndex = function positionForIndex(index, cells, heightIndex) {\n  var cell = cells.find(function (c) {\n    return c.type === CELL_TYPE_ITEM && c.index === index;\n  });\n\n  if (cell) {\n    return heightIndex[cell.i];\n  }\n\n  return -1;\n};\n\nvar VirtualScroll =\n/** @class */\nfunction () {\n  function VirtualScroll(hostRef) {\n    var _this = this;\n\n    registerInstance(this, hostRef);\n    this.range = {\n      offset: 0,\n      length: 0\n    };\n    this.viewportHeight = 0;\n    this.cells = [];\n    this.virtualDom = [];\n    this.isEnabled = false;\n    this.viewportOffset = 0;\n    this.currentScrollTop = 0;\n    this.indexDirty = 0;\n    this.lastItemLen = 0;\n    this.totalHeight = 0;\n    /**\n     * It is important to provide this\n     * if virtual item height will be significantly larger than the default\n     * The approximate height of each virtual item template's cell.\n     * This dimension is used to help determine how many cells should\n     * be created when initialized, and to help calculate the height of\n     * the scrollable area. This height value can only use `px` units.\n     * Note that the actual rendered size of each cell comes from the\n     * app's CSS, whereas this approximation is used to help calculate\n     * initial dimensions before the item has been rendered.\n     */\n\n    this.approxItemHeight = 45;\n    /**\n     * The approximate height of each header template's cell.\n     * This dimension is used to help determine how many cells should\n     * be created when initialized, and to help calculate the height of\n     * the scrollable area. This height value can only use `px` units.\n     * Note that the actual rendered size of each cell comes from the\n     * app's CSS, whereas this approximation is used to help calculate\n     * initial dimensions before the item has been rendered.\n     */\n\n    this.approxHeaderHeight = 30;\n    /**\n     * The approximate width of each footer template's cell.\n     * This dimension is used to help determine how many cells should\n     * be created when initialized, and to help calculate the height of\n     * the scrollable area. This height value can only use `px` units.\n     * Note that the actual rendered size of each cell comes from the\n     * app's CSS, whereas this approximation is used to help calculate\n     * initial dimensions before the item has been rendered.\n     */\n\n    this.approxFooterHeight = 30;\n\n    this.onScroll = function () {\n      _this.updateVirtualScroll();\n    };\n  }\n\n  VirtualScroll.prototype.itemsChanged = function () {\n    this.calcCells();\n    this.updateVirtualScroll();\n  };\n\n  VirtualScroll.prototype.componentDidLoad = function () {\n    return tslib_1.__awaiter(this, void 0, void 0, function () {\n      var contentEl, _a;\n\n      return tslib_1.__generator(this, function (_b) {\n        switch (_b.label) {\n          case 0:\n            contentEl = this.el.closest('ion-content');\n\n            if (!contentEl) {\n              console.error('virtual-scroll must be used inside ion-content');\n              return [2\n              /*return*/\n              ];\n            }\n\n            return [4\n            /*yield*/\n            , contentEl.componentOnReady()];\n\n          case 1:\n            _b.sent();\n\n            this.contentEl = contentEl;\n            _a = this;\n            return [4\n            /*yield*/\n            , contentEl.getScrollElement()];\n\n          case 2:\n            _a.scrollEl = _b.sent();\n            this.calcCells();\n            this.updateState();\n            return [2\n            /*return*/\n            ];\n        }\n      });\n    });\n  };\n\n  VirtualScroll.prototype.componentDidUpdate = function () {\n    this.updateState();\n  };\n\n  VirtualScroll.prototype.componentDidUnload = function () {\n    this.scrollEl = undefined;\n  };\n\n  VirtualScroll.prototype.onResize = function () {\n    this.calcCells();\n    this.updateVirtualScroll();\n  };\n  /**\n   * Returns the position of the virtual item at the given index.\n   */\n\n\n  VirtualScroll.prototype.positionForItem = function (index) {\n    return Promise.resolve(positionForIndex(index, this.cells, this.getHeightIndex()));\n  };\n  /**\n   * This method marks a subset of items as dirty, so they can be re-rendered. Items should be marked as\n   * dirty any time the content or their style changes.\n   *\n   * The subset of items to be updated can are specifing by an offset and a length.\n   */\n\n\n  VirtualScroll.prototype.checkRange = function (offset, len) {\n    if (len === void 0) {\n      len = -1;\n    }\n\n    return tslib_1.__awaiter(this, void 0, void 0, function () {\n      var length, cellIndex, cells;\n      return tslib_1.__generator(this, function (_a) {\n        // TODO: kind of hacky how we do in-place updated of the cells\n        // array. this part needs a complete refactor\n        if (!this.items) {\n          return [2\n          /*return*/\n          ];\n        }\n\n        length = len === -1 ? this.items.length - offset : len;\n        cellIndex = findCellIndex(this.cells, offset);\n        cells = calcCells(this.items, this.itemHeight, this.headerHeight, this.footerHeight, this.headerFn, this.footerFn, this.approxHeaderHeight, this.approxFooterHeight, this.approxItemHeight, cellIndex, offset, length);\n        this.cells = inplaceUpdate(this.cells, cells, cellIndex);\n        this.lastItemLen = this.items.length;\n        this.indexDirty = Math.max(offset - 1, 0);\n        this.scheduleUpdate();\n        return [2\n        /*return*/\n        ];\n      });\n    });\n  };\n  /**\n   * This method marks the tail the items array as dirty, so they can be re-rendered.\n   *\n   * It's equivalent to calling:\n   *\n   * ```js\n   * virtualScroll.checkRange(lastItemLen);\n   * ```\n   */\n\n\n  VirtualScroll.prototype.checkEnd = function () {\n    return tslib_1.__awaiter(this, void 0, void 0, function () {\n      return tslib_1.__generator(this, function (_a) {\n        if (this.items) {\n          this.checkRange(this.lastItemLen);\n        }\n\n        return [2\n        /*return*/\n        ];\n      });\n    });\n  };\n\n  VirtualScroll.prototype.updateVirtualScroll = function () {\n    // do nothing if virtual-scroll is disabled\n    if (!this.isEnabled || !this.scrollEl) {\n      return;\n    } // unschedule future updates\n\n\n    if (this.timerUpdate) {\n      clearTimeout(this.timerUpdate);\n      this.timerUpdate = undefined;\n    } // schedule DOM operations into the stencil queue\n\n\n    readTask(this.readVS.bind(this));\n    writeTask(this.writeVS.bind(this));\n  };\n\n  VirtualScroll.prototype.readVS = function () {\n    var _a = this,\n        contentEl = _a.contentEl,\n        scrollEl = _a.scrollEl,\n        el = _a.el;\n\n    var topOffset = 0;\n    var node = el;\n\n    while (node && node !== contentEl) {\n      topOffset += node.offsetTop;\n      node = node.parentElement;\n    }\n\n    this.viewportOffset = topOffset;\n\n    if (scrollEl) {\n      this.viewportHeight = scrollEl.offsetHeight;\n      this.currentScrollTop = scrollEl.scrollTop;\n    }\n  };\n\n  VirtualScroll.prototype.writeVS = function () {\n    var dirtyIndex = this.indexDirty; // get visible viewport\n\n    var scrollTop = this.currentScrollTop - this.viewportOffset;\n    var viewport = getViewport(scrollTop, this.viewportHeight, 100); // compute lazily the height index\n\n    var heightIndex = this.getHeightIndex(); // get array bounds of visible cells base in the viewport\n\n    var range = getRange(heightIndex, viewport, 2); // fast path, do nothing\n\n    var shouldUpdate = getShouldUpdate(dirtyIndex, this.range, range);\n\n    if (!shouldUpdate) {\n      return;\n    }\n\n    this.range = range; // in place mutation of the virtual DOM\n\n    updateVDom(this.virtualDom, heightIndex, this.cells, range); // Write DOM\n    // Different code paths taken depending of the render API used\n\n    if (this.nodeRender) {\n      doRender(this.el, this.nodeRender, this.virtualDom, this.updateCellHeight.bind(this));\n    } else if (this.domRender) {\n      this.domRender(this.virtualDom);\n    } else if (this.renderItem) {\n      this.el.forceUpdate();\n    }\n  };\n\n  VirtualScroll.prototype.updateCellHeight = function (cell, node) {\n    var _this = this;\n\n    var update = function update() {\n      if (node['$ionCell'] === cell) {\n        var style = window.getComputedStyle(node);\n        var height = node.offsetHeight + parseFloat(style.getPropertyValue('margin-bottom'));\n\n        _this.setCellHeight(cell, height);\n      }\n    };\n\n    if (node && node.componentOnReady) {\n      node.componentOnReady().then(update);\n    } else {\n      update();\n    }\n  };\n\n  VirtualScroll.prototype.setCellHeight = function (cell, height) {\n    var index = cell.i; // the cell might changed since the height update was scheduled\n\n    if (cell !== this.cells[index]) {\n      return;\n    }\n\n    if (cell.height !== height || cell.visible !== true) {\n      cell.visible = true;\n      cell.height = height;\n      this.indexDirty = Math.min(this.indexDirty, index);\n      this.scheduleUpdate();\n    }\n  };\n\n  VirtualScroll.prototype.scheduleUpdate = function () {\n    var _this = this;\n\n    clearTimeout(this.timerUpdate);\n    this.timerUpdate = setTimeout(function () {\n      return _this.updateVirtualScroll();\n    }, 100);\n  };\n\n  VirtualScroll.prototype.updateState = function () {\n    var shouldEnable = !!(this.scrollEl && this.cells);\n\n    if (shouldEnable !== this.isEnabled) {\n      this.enableScrollEvents(shouldEnable);\n\n      if (shouldEnable) {\n        this.updateVirtualScroll();\n      }\n    }\n  };\n\n  VirtualScroll.prototype.calcCells = function () {\n    if (!this.items) {\n      return;\n    }\n\n    this.lastItemLen = this.items.length;\n    this.cells = calcCells(this.items, this.itemHeight, this.headerHeight, this.footerHeight, this.headerFn, this.footerFn, this.approxHeaderHeight, this.approxFooterHeight, this.approxItemHeight, 0, 0, this.lastItemLen);\n    this.indexDirty = 0;\n  };\n\n  VirtualScroll.prototype.getHeightIndex = function () {\n    if (this.indexDirty !== Infinity) {\n      this.calcHeightIndex(this.indexDirty);\n    }\n\n    return this.heightIndex;\n  };\n\n  VirtualScroll.prototype.calcHeightIndex = function (index) {\n    if (index === void 0) {\n      index = 0;\n    } // TODO: optimize, we don't need to calculate all the cells\n\n\n    this.heightIndex = resizeBuffer(this.heightIndex, this.cells.length);\n    this.totalHeight = calcHeightIndex(this.heightIndex, this.cells, index);\n    this.indexDirty = Infinity;\n  };\n\n  VirtualScroll.prototype.enableScrollEvents = function (shouldListen) {\n    var _this = this;\n\n    if (this.rmEvent) {\n      this.rmEvent();\n      this.rmEvent = undefined;\n    }\n\n    var scrollEl = this.scrollEl;\n\n    if (scrollEl) {\n      this.isEnabled = shouldListen;\n      scrollEl.addEventListener('scroll', this.onScroll);\n\n      this.rmEvent = function () {\n        scrollEl.removeEventListener('scroll', _this.onScroll);\n      };\n    }\n  };\n\n  VirtualScroll.prototype.renderVirtualNode = function (node) {\n    var _a = node.cell,\n        type = _a.type,\n        value = _a.value,\n        index = _a.index;\n\n    switch (type) {\n      case CELL_TYPE_ITEM:\n        return this.renderItem(value, index);\n\n      case CELL_TYPE_HEADER:\n        return this.renderHeader(value, index);\n\n      case CELL_TYPE_FOOTER:\n        return this.renderFooter(value, index);\n    }\n  };\n\n  VirtualScroll.prototype.hostData = function () {\n    return {\n      style: {\n        height: this.totalHeight + \"px\"\n      }\n    };\n  };\n\n  VirtualScroll.prototype.__stencil_render = function () {\n    var _this = this;\n\n    if (this.renderItem) {\n      return h(VirtualProxy, {\n        dom: this.virtualDom\n      }, this.virtualDom.map(function (node) {\n        return _this.renderVirtualNode(node);\n      }));\n    }\n\n    return undefined;\n  };\n\n  Object.defineProperty(VirtualScroll.prototype, \"el\", {\n    get: function get() {\n      return getElement(this);\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(VirtualScroll, \"watchers\", {\n    get: function get() {\n      return {\n        \"itemHeight\": [\"itemsChanged\"],\n        \"headerHeight\": [\"itemsChanged\"],\n        \"footerHeight\": [\"itemsChanged\"],\n        \"items\": [\"itemsChanged\"]\n      };\n    },\n    enumerable: true,\n    configurable: true\n  });\n\n  VirtualScroll.prototype.render = function () {\n    return h(Host, this.hostData(), this.__stencil_render());\n  };\n\n  Object.defineProperty(VirtualScroll, \"style\", {\n    get: function get() {\n      return \"ion-virtual-scroll{display:block;position:relative;width:100%;contain:strict;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}ion-virtual-scroll>.virtual-loading{opacity:0}ion-virtual-scroll>.virtual-item{position:absolute!important;top:0!important;right:0!important;left:0!important;-webkit-transition-duration:0ms;transition-duration:0ms;will-change:transform}\";\n    },\n    enumerable: true,\n    configurable: true\n  });\n  return VirtualScroll;\n}();\n\nvar VirtualProxy = function VirtualProxy(_a, children, utils) {\n  var dom = _a.dom;\n  return utils.map(children, function (child, i) {\n    var node = dom[i];\n    var vattrs = child.vattrs || {};\n    var classes = vattrs.class || '';\n    classes += 'virtual-item ';\n\n    if (!node.visible) {\n      classes += 'virtual-loading';\n    }\n\n    return Object.assign({}, child, {\n      vattrs: Object.assign({}, vattrs, {\n        class: classes,\n        style: Object.assign({}, vattrs.style, {\n          transform: \"translate3d(0,\" + node.top + \"px,0)\"\n        })\n      })\n    });\n  });\n};\n\nexport { VirtualScroll as ion_virtual_scroll };"],"sourceRoot":""}