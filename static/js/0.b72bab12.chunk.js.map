{"version":3,"sources":["../node_modules/@ionic/core/dist/esm-es5/index-8421816f.js"],"names":["__webpack_require__","r","__webpack_exports__","d","GESTURE_CONTROLLER","createGesture","_sPassive","_chunk_84f6bf13_js__WEBPACK_IMPORTED_MODULE_0__","GestureController","this","gestureId","requestedStart","Map","disabledGestures","disabledScroll","Set","prototype","config","GestureDelegate","newID","name","priority","disableScroll","createBlocker","opts","BlockerDelegate","disable","start","gestureName","id","canStart","set","delete","capture","maxPriority","forEach","value","Math","max","capturedId","clear","event","CustomEvent","detail","document","dispatchEvent","release","undefined","disableGesture","get","add","enableGesture","size","body","classList","BACKDROP_NO_SCROLL","enableScroll","remove","isDisabled","isCaptured","isScrollDisabled","disabled","ctrl","captured","destroy","block","_i","_a","length","gesture","unblock","addEventListener","el","eventName","callback","listenerOpts","supportsPassive","passive","node","Object","defineProperty","e","getDocument","Document","ownerDocument","hasCapturedPan","hasStartedPan","hasFiredStart","isMoveQueued","finalConfig","assign","direction","gesturePriority","maxAngle","threshold","onWillStart","onStart","onEnd","notCaptured","onMove","type","startX","startY","startTimeStamp","currentX","currentY","velocityX","velocityY","deltaX","deltaY","timeStamp","data","pan","thresh","radians","PI","isDirX","maxCosine","cos","dirty","isPan","x","y","detect","distance","hypotenuse","sqrt","cosine","isGesture","getDirection","createPanRecognizer","fireOnMove","tryToCapturePan","then","fireOnStart","reset","pointerUp","ev","tmpHasCaptured","tmpHasFiredStart","calcGestureData","pointerEvents","pointerDown","pointerMove","options","rmTouchStart","rmTouchMove","rmTouchEnd","rmTouchCancel","rmMouseStart","rmMouseMove","rmMouseUp","lastTouchEvent","handleTouchStart","Date","now","handleTouchEnd","handleMouseDown","handleMouseUp","stopTouch","stopMouse","stop","setDisabled","createPointerEvents","updateDetail","abortGesture","prevX","prevY","prevT","timeDelta","changedTouches","touch","clientX","clientY","pageX","pageY"],"mappings":"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","file":"static/js/0.b72bab12.chunk.js","sourcesContent":["import { w as writeTask } from './chunk-84f6bf13.js';\nimport './chunk-1074393c.js';\n\nvar GestureController =\n/** @class */\nfunction () {\n  function GestureController() {\n    this.gestureId = 0;\n    this.requestedStart = new Map();\n    this.disabledGestures = new Map();\n    this.disabledScroll = new Set();\n  }\n  /**\n   * Creates a gesture delegate based on the GestureConfig passed\n   */\n\n\n  GestureController.prototype.createGesture = function (config) {\n    return new GestureDelegate(this, this.newID(), config.name, config.priority || 0, !!config.disableScroll);\n  };\n  /**\n   * Creates a blocker that will block any other gesture events from firing. Set in the ion-gesture component.\n   */\n\n\n  GestureController.prototype.createBlocker = function (opts) {\n    if (opts === void 0) {\n      opts = {};\n    }\n\n    return new BlockerDelegate(this, this.newID(), opts.disable, !!opts.disableScroll);\n  };\n\n  GestureController.prototype.start = function (gestureName, id, priority) {\n    if (!this.canStart(gestureName)) {\n      this.requestedStart.delete(id);\n      return false;\n    }\n\n    this.requestedStart.set(id, priority);\n    return true;\n  };\n\n  GestureController.prototype.capture = function (gestureName, id, priority) {\n    if (!this.start(gestureName, id, priority)) {\n      return false;\n    }\n\n    var requestedStart = this.requestedStart;\n    var maxPriority = -10000;\n    requestedStart.forEach(function (value) {\n      maxPriority = Math.max(maxPriority, value);\n    });\n\n    if (maxPriority === priority) {\n      this.capturedId = id;\n      requestedStart.clear();\n      var event = new CustomEvent('ionGestureCaptured', {\n        detail: {\n          gestureName: gestureName\n        }\n      });\n      document.dispatchEvent(event);\n      return true;\n    }\n\n    requestedStart.delete(id);\n    return false;\n  };\n\n  GestureController.prototype.release = function (id) {\n    this.requestedStart.delete(id);\n\n    if (this.capturedId === id) {\n      this.capturedId = undefined;\n    }\n  };\n\n  GestureController.prototype.disableGesture = function (gestureName, id) {\n    var set = this.disabledGestures.get(gestureName);\n\n    if (set === undefined) {\n      set = new Set();\n      this.disabledGestures.set(gestureName, set);\n    }\n\n    set.add(id);\n  };\n\n  GestureController.prototype.enableGesture = function (gestureName, id) {\n    var set = this.disabledGestures.get(gestureName);\n\n    if (set !== undefined) {\n      set.delete(id);\n    }\n  };\n\n  GestureController.prototype.disableScroll = function (id) {\n    this.disabledScroll.add(id);\n\n    if (this.disabledScroll.size === 1) {\n      document.body.classList.add(BACKDROP_NO_SCROLL);\n    }\n  };\n\n  GestureController.prototype.enableScroll = function (id) {\n    this.disabledScroll.delete(id);\n\n    if (this.disabledScroll.size === 0) {\n      document.body.classList.remove(BACKDROP_NO_SCROLL);\n    }\n  };\n\n  GestureController.prototype.canStart = function (gestureName) {\n    if (this.capturedId !== undefined) {\n      // a gesture already captured\n      return false;\n    }\n\n    if (this.isDisabled(gestureName)) {\n      return false;\n    }\n\n    return true;\n  };\n\n  GestureController.prototype.isCaptured = function () {\n    return this.capturedId !== undefined;\n  };\n\n  GestureController.prototype.isScrollDisabled = function () {\n    return this.disabledScroll.size > 0;\n  };\n\n  GestureController.prototype.isDisabled = function (gestureName) {\n    var disabled = this.disabledGestures.get(gestureName);\n\n    if (disabled && disabled.size > 0) {\n      return true;\n    }\n\n    return false;\n  };\n\n  GestureController.prototype.newID = function () {\n    this.gestureId++;\n    return this.gestureId;\n  };\n\n  return GestureController;\n}();\n\nvar GestureDelegate =\n/** @class */\nfunction () {\n  function GestureDelegate(ctrl, id, name, priority, disableScroll) {\n    this.id = id;\n    this.name = name;\n    this.disableScroll = disableScroll;\n    this.priority = priority * 1000000 + id;\n    this.ctrl = ctrl;\n  }\n\n  GestureDelegate.prototype.canStart = function () {\n    if (!this.ctrl) {\n      return false;\n    }\n\n    return this.ctrl.canStart(this.name);\n  };\n\n  GestureDelegate.prototype.start = function () {\n    if (!this.ctrl) {\n      return false;\n    }\n\n    return this.ctrl.start(this.name, this.id, this.priority);\n  };\n\n  GestureDelegate.prototype.capture = function () {\n    if (!this.ctrl) {\n      return false;\n    }\n\n    var captured = this.ctrl.capture(this.name, this.id, this.priority);\n\n    if (captured && this.disableScroll) {\n      this.ctrl.disableScroll(this.id);\n    }\n\n    return captured;\n  };\n\n  GestureDelegate.prototype.release = function () {\n    if (this.ctrl) {\n      this.ctrl.release(this.id);\n\n      if (this.disableScroll) {\n        this.ctrl.enableScroll(this.id);\n      }\n    }\n  };\n\n  GestureDelegate.prototype.destroy = function () {\n    this.release();\n    this.ctrl = undefined;\n  };\n\n  return GestureDelegate;\n}();\n\nvar BlockerDelegate =\n/** @class */\nfunction () {\n  function BlockerDelegate(ctrl, id, disable, disableScroll) {\n    this.id = id;\n    this.disable = disable;\n    this.disableScroll = disableScroll;\n    this.ctrl = ctrl;\n  }\n\n  BlockerDelegate.prototype.block = function () {\n    if (!this.ctrl) {\n      return;\n    }\n\n    if (this.disable) {\n      for (var _i = 0, _a = this.disable; _i < _a.length; _i++) {\n        var gesture = _a[_i];\n        this.ctrl.disableGesture(gesture, this.id);\n      }\n    }\n\n    if (this.disableScroll) {\n      this.ctrl.disableScroll(this.id);\n    }\n  };\n\n  BlockerDelegate.prototype.unblock = function () {\n    if (!this.ctrl) {\n      return;\n    }\n\n    if (this.disable) {\n      for (var _i = 0, _a = this.disable; _i < _a.length; _i++) {\n        var gesture = _a[_i];\n        this.ctrl.enableGesture(gesture, this.id);\n      }\n    }\n\n    if (this.disableScroll) {\n      this.ctrl.enableScroll(this.id);\n    }\n  };\n\n  BlockerDelegate.prototype.destroy = function () {\n    this.unblock();\n    this.ctrl = undefined;\n  };\n\n  return BlockerDelegate;\n}();\n\nvar BACKDROP_NO_SCROLL = 'backdrop-no-scroll';\nvar GESTURE_CONTROLLER = new GestureController();\n\nvar addEventListener = function addEventListener(el, eventName, callback, opts) {\n  // use event listener options when supported\n  // otherwise it's just a boolean for the \"capture\" arg\n  var listenerOpts = supportsPassive(el) ? {\n    'capture': !!opts.capture,\n    'passive': !!opts.passive\n  } : !!opts.capture;\n  var add;\n  var remove;\n\n  if (el['__zone_symbol__addEventListener']) {\n    add = '__zone_symbol__addEventListener';\n    remove = '__zone_symbol__removeEventListener';\n  } else {\n    add = 'addEventListener';\n    remove = 'removeEventListener';\n  }\n\n  el[add](eventName, callback, listenerOpts);\n  return function () {\n    el[remove](eventName, callback, listenerOpts);\n  };\n};\n\nvar supportsPassive = function supportsPassive(node) {\n  if (_sPassive === undefined) {\n    try {\n      var opts = Object.defineProperty({}, 'passive', {\n        get: function get() {\n          _sPassive = true;\n        }\n      });\n      node.addEventListener('optsTest', function () {\n        return;\n      }, opts);\n    } catch (e) {\n      _sPassive = false;\n    }\n  }\n\n  return !!_sPassive;\n};\n\nvar _sPassive;\n\nvar MOUSE_WAIT = 2000;\n\nvar createPointerEvents = function createPointerEvents(el, pointerDown, pointerMove, pointerUp, options) {\n  var rmTouchStart;\n  var rmTouchMove;\n  var rmTouchEnd;\n  var rmTouchCancel;\n  var rmMouseStart;\n  var rmMouseMove;\n  var rmMouseUp;\n  var lastTouchEvent = 0;\n\n  var handleTouchStart = function handleTouchStart(ev) {\n    lastTouchEvent = Date.now() + MOUSE_WAIT;\n\n    if (!pointerDown(ev)) {\n      return;\n    }\n\n    if (!rmTouchMove && pointerMove) {\n      rmTouchMove = addEventListener(el, 'touchmove', pointerMove, options);\n    }\n\n    if (!rmTouchEnd) {\n      rmTouchEnd = addEventListener(el, 'touchend', handleTouchEnd, options);\n    }\n\n    if (!rmTouchCancel) {\n      rmTouchCancel = addEventListener(el, 'touchcancel', handleTouchEnd, options);\n    }\n  };\n\n  var handleMouseDown = function handleMouseDown(ev) {\n    if (lastTouchEvent > Date.now()) {\n      return;\n    }\n\n    if (!pointerDown(ev)) {\n      return;\n    }\n\n    if (!rmMouseMove && pointerMove) {\n      rmMouseMove = addEventListener(getDocument(el), 'mousemove', pointerMove, options);\n    }\n\n    if (!rmMouseUp) {\n      rmMouseUp = addEventListener(getDocument(el), 'mouseup', handleMouseUp, options);\n    }\n  };\n\n  var handleTouchEnd = function handleTouchEnd(ev) {\n    stopTouch();\n\n    if (pointerUp) {\n      pointerUp(ev);\n    }\n  };\n\n  var handleMouseUp = function handleMouseUp(ev) {\n    stopMouse();\n\n    if (pointerUp) {\n      pointerUp(ev);\n    }\n  };\n\n  var stopTouch = function stopTouch() {\n    if (rmTouchMove) {\n      rmTouchMove();\n    }\n\n    if (rmTouchEnd) {\n      rmTouchEnd();\n    }\n\n    if (rmTouchCancel) {\n      rmTouchCancel();\n    }\n\n    rmTouchMove = rmTouchEnd = rmTouchCancel = undefined;\n  };\n\n  var stopMouse = function stopMouse() {\n    if (rmMouseMove) {\n      rmMouseMove();\n    }\n\n    if (rmMouseUp) {\n      rmMouseUp();\n    }\n\n    rmMouseMove = rmMouseUp = undefined;\n  };\n\n  var stop = function stop() {\n    stopTouch();\n    stopMouse();\n  };\n\n  var setDisabled = function setDisabled(disabled) {\n    if (disabled) {\n      if (rmTouchStart) {\n        rmTouchStart();\n      }\n\n      if (rmMouseStart) {\n        rmMouseStart();\n      }\n\n      rmTouchStart = rmMouseStart = undefined;\n      stop();\n    } else {\n      if (!rmTouchStart) {\n        rmTouchStart = addEventListener(el, 'touchstart', handleTouchStart, options);\n      }\n\n      if (!rmMouseStart) {\n        rmMouseStart = addEventListener(el, 'mousedown', handleMouseDown, options);\n      }\n    }\n  };\n\n  var destroy = function destroy() {\n    setDisabled(true);\n    pointerUp = pointerMove = pointerDown = undefined;\n  };\n\n  return {\n    setDisabled: setDisabled,\n    stop: stop,\n    destroy: destroy\n  };\n};\n\nvar getDocument = function getDocument(node) {\n  return node instanceof Document ? node : node.ownerDocument;\n};\n\nvar createPanRecognizer = function createPanRecognizer(direction, thresh, maxAngle) {\n  var radians = maxAngle * (Math.PI / 180);\n  var isDirX = direction === 'x';\n  var maxCosine = Math.cos(radians);\n  var threshold = thresh * thresh;\n  var startX = 0;\n  var startY = 0;\n  var dirty = false;\n  var isPan = 0;\n  return {\n    start: function start(x, y) {\n      startX = x;\n      startY = y;\n      isPan = 0;\n      dirty = true;\n    },\n    detect: function detect(x, y) {\n      if (!dirty) {\n        return false;\n      }\n\n      var deltaX = x - startX;\n      var deltaY = y - startY;\n      var distance = deltaX * deltaX + deltaY * deltaY;\n\n      if (distance < threshold) {\n        return false;\n      }\n\n      var hypotenuse = Math.sqrt(distance);\n      var cosine = (isDirX ? deltaX : deltaY) / hypotenuse;\n\n      if (cosine > maxCosine) {\n        isPan = 1;\n      } else if (cosine < -maxCosine) {\n        isPan = -1;\n      } else {\n        isPan = 0;\n      }\n\n      dirty = false;\n      return true;\n    },\n    isGesture: function isGesture() {\n      return isPan !== 0;\n    },\n    getDirection: function getDirection() {\n      return isPan;\n    }\n  };\n};\n\nvar createGesture = function createGesture(config) {\n  var hasCapturedPan = false;\n  var hasStartedPan = false;\n  var hasFiredStart = true;\n  var isMoveQueued = false;\n  var finalConfig = Object.assign({\n    disableScroll: false,\n    direction: 'x',\n    gesturePriority: 0,\n    passive: true,\n    maxAngle: 40,\n    threshold: 10\n  }, config);\n  var canStart = finalConfig.canStart;\n  var onWillStart = finalConfig.onWillStart;\n  var onStart = finalConfig.onStart;\n  var onEnd = finalConfig.onEnd;\n  var notCaptured = finalConfig.notCaptured;\n  var onMove = finalConfig.onMove;\n  var threshold = finalConfig.threshold;\n  var detail = {\n    type: 'pan',\n    startX: 0,\n    startY: 0,\n    startTimeStamp: 0,\n    currentX: 0,\n    currentY: 0,\n    velocityX: 0,\n    velocityY: 0,\n    deltaX: 0,\n    deltaY: 0,\n    timeStamp: 0,\n    event: undefined,\n    data: undefined\n  };\n  var pan = createPanRecognizer(finalConfig.direction, finalConfig.threshold, finalConfig.maxAngle);\n  var gesture = GESTURE_CONTROLLER.createGesture({\n    name: config.gestureName,\n    priority: config.gesturePriority,\n    disableScroll: config.disableScroll\n  });\n\n  var pointerDown = function pointerDown(ev) {\n    var timeStamp = now(ev);\n\n    if (hasStartedPan || !hasFiredStart) {\n      return false;\n    }\n\n    updateDetail(ev, detail);\n    detail.startX = detail.currentX;\n    detail.startY = detail.currentY;\n    detail.startTimeStamp = detail.timeStamp = timeStamp;\n    detail.velocityX = detail.velocityY = detail.deltaX = detail.deltaY = 0;\n    detail.event = ev; // Check if gesture can start\n\n    if (canStart && canStart(detail) === false) {\n      return false;\n    } // Release fallback\n\n\n    gesture.release(); // Start gesture\n\n    if (!gesture.start()) {\n      return false;\n    }\n\n    hasStartedPan = true;\n\n    if (threshold === 0) {\n      return tryToCapturePan();\n    }\n\n    pan.start(detail.startX, detail.startY);\n    return true;\n  };\n\n  var pointerMove = function pointerMove(ev) {\n    // fast path, if gesture is currently captured\n    // do minimum job to get user-land even dispatched\n    if (hasCapturedPan) {\n      if (!isMoveQueued && hasFiredStart) {\n        isMoveQueued = true;\n        calcGestureData(detail, ev);\n        writeTask(fireOnMove);\n      }\n\n      return;\n    } // gesture is currently being detected\n\n\n    calcGestureData(detail, ev);\n\n    if (pan.detect(detail.currentX, detail.currentY)) {\n      if (!pan.isGesture() || !tryToCapturePan()) {\n        abortGesture();\n      }\n    }\n  };\n\n  var fireOnMove = function fireOnMove() {\n    // Since fireOnMove is called inside a RAF, onEnd() might be called,\n    // we must double check hasCapturedPan\n    if (!hasCapturedPan) {\n      return;\n    }\n\n    isMoveQueued = false;\n\n    if (onMove) {\n      onMove(detail);\n    }\n  };\n\n  var tryToCapturePan = function tryToCapturePan() {\n    if (gesture && !gesture.capture()) {\n      return false;\n    }\n\n    hasCapturedPan = true;\n    hasFiredStart = false; // reset start position since the real user-land event starts here\n    // If the pan detector threshold is big, not resetting the start position\n    // will cause a jump in the animation equal to the detector threshold.\n    // the array of positions used to calculate the gesture velocity does not\n    // need to be cleaned, more points in the positions array always results in a\n    // more accurate value of the velocity.\n\n    detail.startX = detail.currentX;\n    detail.startY = detail.currentY;\n    detail.startTimeStamp = detail.timeStamp;\n\n    if (onWillStart) {\n      onWillStart(detail).then(fireOnStart);\n    } else {\n      fireOnStart();\n    }\n\n    return true;\n  };\n\n  var fireOnStart = function fireOnStart() {\n    if (onStart) {\n      onStart(detail);\n    }\n\n    hasFiredStart = true;\n  };\n\n  var reset = function reset() {\n    hasCapturedPan = false;\n    hasStartedPan = false;\n    isMoveQueued = false;\n    hasFiredStart = true;\n    gesture.release();\n  }; // END *************************\n\n\n  var pointerUp = function pointerUp(ev) {\n    var tmpHasCaptured = hasCapturedPan;\n    var tmpHasFiredStart = hasFiredStart;\n    reset();\n\n    if (!tmpHasFiredStart) {\n      return;\n    }\n\n    calcGestureData(detail, ev); // Try to capture press\n\n    if (tmpHasCaptured) {\n      if (onEnd) {\n        onEnd(detail);\n      }\n\n      return;\n    } // Not captured any event\n\n\n    if (notCaptured) {\n      notCaptured(detail);\n    }\n  };\n\n  var pointerEvents = createPointerEvents(finalConfig.el, pointerDown, pointerMove, pointerUp, {\n    capture: false\n  });\n\n  var abortGesture = function abortGesture() {\n    reset();\n    pointerEvents.stop();\n\n    if (notCaptured) {\n      notCaptured(detail);\n    }\n  };\n\n  return {\n    setDisabled: function setDisabled(disabled) {\n      if (disabled && hasCapturedPan) {\n        pointerUp(undefined);\n      }\n\n      pointerEvents.setDisabled(disabled);\n    },\n    destroy: function destroy() {\n      gesture.destroy();\n      pointerEvents.destroy();\n    }\n  };\n};\n\nvar calcGestureData = function calcGestureData(detail, ev) {\n  if (!ev) {\n    return;\n  }\n\n  var prevX = detail.currentX;\n  var prevY = detail.currentY;\n  var prevT = detail.timeStamp;\n  updateDetail(ev, detail);\n  var currentX = detail.currentX;\n  var currentY = detail.currentY;\n  var timestamp = detail.timeStamp = now(ev);\n  var timeDelta = timestamp - prevT;\n\n  if (timeDelta > 0 && timeDelta < 100) {\n    var velocityX = (currentX - prevX) / timeDelta;\n    var velocityY = (currentY - prevY) / timeDelta;\n    detail.velocityX = velocityX * 0.7 + detail.velocityX * 0.3;\n    detail.velocityY = velocityY * 0.7 + detail.velocityY * 0.3;\n  }\n\n  detail.deltaX = currentX - detail.startX;\n  detail.deltaY = currentY - detail.startY;\n  detail.event = ev;\n};\n\nvar updateDetail = function updateDetail(ev, detail) {\n  // get X coordinates for either a mouse click\n  // or a touch depending on the given event\n  var x = 0;\n  var y = 0;\n\n  if (ev) {\n    var changedTouches = ev.changedTouches;\n\n    if (changedTouches && changedTouches.length > 0) {\n      var touch = changedTouches[0];\n      x = touch.clientX;\n      y = touch.clientY;\n    } else if (ev.pageX !== undefined) {\n      x = ev.pageX;\n      y = ev.pageY;\n    }\n  }\n\n  detail.currentX = x;\n  detail.currentY = y;\n};\n\nvar now = function now(ev) {\n  return ev.timeStamp || Date.now();\n};\n\nexport { GESTURE_CONTROLLER, createGesture };"],"sourceRoot":""}